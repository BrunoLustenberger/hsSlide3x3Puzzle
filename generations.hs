{- |
Module : Generations
Description : Generating new boards from a given board repeatedly.
Copyright : (c) 2022 Bruno M.S. Lustenberger

The children of a given board are all boards that can be generated by
moving the "empty" tile into one of the four directions. From these boards
new children can be generated etc. 

We consider the endBoard as the "prime ancestor", its children are 
the 1st generation, their children are the 2nd generation etc.

For each board within a generation the sequence of moves, that generates this
board, is preserved. To achieve this, we extend the type Board.

Within a generation there may be several boards with identical tile positions.
Such duplicates are eliminated. To achieve this, we first sort each generation.
-}
module Generations
{- Uncomment for tests 
    ( Pedigree
    , ExBoard(..)
    , exEndBoard
    , Generation
    , nextGen
    , sortGen
    , compressGen
    )-}
where

import Data.List (sortBy)

import Boards

-- |The sequence of moves leading to a certain board can be considered
--  the pedigree of the board. Most recent move is at head of list.
type Pedigree = [Direction]

-- |An extended board contains the board and its pedigree.
data ExBoard = ExBoard {
      board :: Board
    , pedigree :: Pedigree 
    } deriving (Show, Eq)

-- |Moves the board extending its pedigree
generate :: Direction -> ExBoard -> ExBoard
generate d (ExBoard b p) = ExBoard (move d b) (d:p)

-- |The prime ancestor
exEndBoard = ExBoard [1,2,3,4,5,6,7,8,9] []

-- |A generation consists of extended boards. 
type Generation = [ExBoard]

-- |All boards that can be generated with 1 move from a given board
children :: ExBoard -> Generation
children e = foldr (\ d es -> (generate d e) : es) [] 
                   (possibleDirections (board e))

-- |Generates the next generation from a given generation
nextGen :: Generation -> Generation
nextGen = concat . (map children)

-- |Extended Boards are ordered by comparing the contained board.
compareEB :: ExBoard -> ExBoard -> Ordering
compareEB eb1 eb2
    | board eb1 < board eb2    = LT
    | board eb1 < board eb2    = EQ
    | otherwise                = GT

-- |Sorts a generation according to the ordering of extended boards.
sortGen :: Generation -> Generation
sortGen = sortBy compareEB

-- |Consecutive elements containing the same board are replaced
--  by the first element. Thus, if the generation has been sorted before,
--  all duplicates are removed.
compressGen :: Generation -> Generation
compressGen = foldr upd [] where
    upd :: ExBoard -> Generation -> Generation
    upd e [] = [e]
    upd e (e1:es) = if board e == board e1 then (e:es) else (e:e1:es)
